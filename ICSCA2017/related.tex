\section{Related work} \label{sec:RelatedWork}
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Paragraph 1:Linux Scalability의 연구에 대한 설명
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\ifkor
\noindent
\textbf{Operating system scalability.}
~\cite{Clements15SCR}In order to improve Linux scalability, researchers have
been optimized memory management in Linux by finding and fixing scalability
bottlenecks~\cite{BoydWickizer2008Corey}~\cite{BoydWickizer2012OLS}.
Shared address spaces in multithreaded applications 
easily become scalability bottlenecks since kernel operations 
including \code{mmap} and \code{munmap} system calls and \code{page faults}
 handling require per-process locks for synchronization.
Multithreaded application, for example, can become bottleneck by kernel
operations on their shared address space, whose operations are the \code{mmap}
and \code{munmap} system calls and \code{page faults}.
These operations are synchronized by a single per-process lock.
BonsaiVM~\cite{AustinTClements2012RCUBalancedTrees} solved this address space
problem by using the RCU;
RadixVM~\cite{Clements2013RadixVM} created a new VM using refcache and radix
tree, which enable \code{munmap}, \code{mmap}, and \code{page fault} on
non-overlapping memory regions to scale perfectly.
Alternatively, to avoid contention caused by shared address space locking,
system programmers change their multithreaded applications to use
processes~\cite{SilasBoydWickizer2010LinuxScales48}.
\else

\fi


