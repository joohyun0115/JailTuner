\section{Introduction} \label{sec:introduction}
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Background : 스파크 -> cloud가 아닌 single node에서의 scalability에 대한 연구가 필요해짐
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\ifkor
빅데이터 처리하는데 중요한 방법 중 하나는 스파크이다.
스파크에 대한 연구는 그동안 
HPC를 위한 스파크가 필요하다. 
리눅스 운영체제가 많이 사용된다. 
기존 연구들은 scale-up 서버에 spark를 적용하기 위한 방법들[][]이 연구되고 있다.
하지만, 이러한 연구들은 리눅스 운영체제의 특징을 활용하지 못하는 문제점이 있다.
리눅스 운영체제 확장성에 대해서 가장 중요한것은 
리눅스는 conflit free한 운영체제가 아니다.
이유는~!!! 여러가지 상황을 고려하였기 때문에 
만약 응용프로그램이 scalalabe하게 디자인이 되어 있다면, 리눅스라도 스케일러블한 
상황으로 만들 수 있다~\cite{SilasBoydWickizer2010LinuxScales48}. 
\else

\fi

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Problem : NUMA 시스템으로 구성된 single node로 scalability가 없음 
% 2가지 관련 연구가 있음.
% 1. 24코어 이하의 서버에서의 Scalability 분석을 하였으나 해결책을 제안하지 않았음.
% 2. HPC(100이상) 으로 분석하였으나 flie system 관점으로 분석하였음.:메인 병목지점은 파일 시스템
% 3. Scalable한 파일 시스템을 사용한 후 Scalability에 대한 분석한 결과와 해결방법은 없음.
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\ifkor
Scale-Up 서버를 위한 scalability 연구들이 진행되고 있다.
하지만, XX et al.은 scale-up 서버에서의 Scalability를 문제점을 구체적으로
분석하여 문제점을 보여주었으나, 해결책을 제안하지 않았다. 
XX et al.는 single note HPC에서의 문제점을 파일 시스템 관점으로 분석하였고, 
파일 시스템 관점으로 성능을 높혔다. 
하지만 아직 scalable한 파일 시스템을 사용해서 발생하는 spark의 scalability에 
문제점에 해결 방법은 아직 연구되지 않았다.
\else


\fi


%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%본 연구에서 분석한 결과와 제안하는 방법으로 향상된 성능
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\ifkor
본 연구는 Scalable한 파일 시스템을 사용하여 파일 시스템에 대한 병목 지점을 
제거한 후 spark scalability를 분석을 하였고, 새로운 파티션닝 기법의 해결책을 제안한다. 
새로운 파티션닝 기법은 docker container를 이용하였고, 그 결과 shared-memory 시스템을 마치
distributed-system 처럼 구성하여 scalability를 향상 시켰다.
우리의 방법은 결국 Scale-up 서버의 NUMA 구조에 따른 memory access latency와 
shared-memory 시스템의 공유 때문에 발생하는 문제들(e.g, lock contention[], 
serialized garbage collect[],
single address space problem[], 
cache communication overhead[])를 해결한다.
\else


\fi



%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%본 연구에서 분석한 결과와 제안하는 방법으로 향상된 성능
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\ifkor
Scalability 문제를 해결하기 위해, 본 연구는 메모리 파티션 기반의 JailDocker를 만들었다. 
JailDocker는 Scale-Up server에서 최적의 성능을 내기 위한 파티션 방법이다. 
기반을 사용하기 우리는 Docker를 사용하였다. 
BigDataBench의 Wordcount on 120core.

\else


\fi

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%본 연구에서 기여한 것 : 
% 1. 100코어 이상의 scale-up 서버에서의 scalability 측정 및 분석
% 2. 도커 파티션 기법을 활용한 scalability 향상 방법 제안
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\ifkor

\textbf{Contributions.} Our research makes the following contributions:
\begin{itemize}
\item We have developed a novel lightweight log-based deferred update method
eliminating the sources of limiting performance scalability in update-heavy data
structures with efficient log management implementation.
\item 
We applied the in Linux kernel to two reverse mapping(anonymous, file) on
an 120 core system to reduce fork scalability bottleneck.
Our design improved throughput and execution time from 1.5x through 2.7x on 120 core.
\end{itemize}

\else

\fi


%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Mapping
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
The rest of this paper is organized as follows.
Section 2 describes the background and the Linux scalability problem.
Section 3 describes the design of the algorithm and 
Section 4 explains how to apply the to Linux kernel, and
Section 5 shows the results of the experimental evaluation. 
Finally, section 6 concludes the paper.


